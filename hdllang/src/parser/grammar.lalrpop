use crate::parser::ast::{ Expression, BinaryOpcode, RangeOpcode, UnaryOpcode, TypeSpecifier, TypeQualifier};
use crate::lexer::*; 
use crate::SourceSpan;
grammar;

Expression: Box<Expression> = {
	<start:@L> <value:"Number"> <end:@R> => 
		Box::new(
			Expression::Number{
				value,
				location:SourceSpan::new_between(start,end)
			}
		),
	<start:@L> <id:"Id"> <end:@R> => 
		Box::new(
			Expression::Identifier{
				id,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L>"(" <expression:Expression> ")" <end:@R> => 
		Box::new(
			Expression::ParenthesizedExpression{
				expression,
				location:SourceSpan::new_between(start,end)
			}
		),
}
pub RangeExpr :  Box<Expression> = {
	<start:@L> "[" <lhs:Expr> <code:RangeOp> <rhs:Expr> "]" <end:@R> =>
		Box::new(
			Expression::RangeExpression{
				lhs,
				rhs,
				code,
				location:SourceSpan::new_between(start,end)
		}
	),
}
PostfixExpr: Box<Expression>={
	<start:@L> <expression:PostfixExpr> "." <id:"Id"> <end:@R> =>
		Box::new(
			Expression::PostfixWithId{
				expression,
				id,
				location:SourceSpan::new_between(start,end),
		}
	),
	<start:@L> <expression:PostfixExpr> "[" <index:PostfixExpr> "]" <end:@R> =>
		Box::new(
			Expression::PostfixWithIndex{
				expression,
				index,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L> <expression:PostfixExpr> <range:RangeExpr> <end:@R> =>
		Box::new(
			Expression::PostfixWithRange{
				expression,
				range,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L> <expression:PostfixExpr> "(" <args:ArgumentList ?> ")" <end:@R> =>
		match args{
			None => Box::new(
				Expression::PostfixEmptyCall{
					expression,
					location:SourceSpan::new_between(start,end),
				}
			),
			Some(argument_list) =>Box::new(
				Expression::PostfixWithArgs{
					expression,
					argument_list,
					location:SourceSpan::new_between(start,end),
				}
			),
		},		
	Expression,
}
UnaryExpr: Box<Expression> ={
	<start:@L> <code:UnaryExprOP> <expression:PostfixExpr>  <end:@R> => 
	Box::new(
		Expression::UnaryOperatorExpression{
			expression,
			code,
			location:SourceSpan::new_between(start,end),
		}
	),
	PostfixExpr,
}
Factor = Tier<FactorOp, UnaryExpr>;
Sum = Tier<AddOp, Factor>;
Shift = Tier<ShiftOp,Sum>;
BitwiseAnd = Tier<BitwiseAndOp,Shift>;
BitwiseXor = Tier<BitwiseXorOp,BitwiseAnd>;
BitwiseOr= Tier<BitwiseOrOp,BitwiseXor>;
Comparison = Tier<RelationalOp,BitwiseOr>;
Equality = Tier<EqualityOp,Comparison>;
LogicalAnd = Tier<LAandOP,Equality>;
LogicalOr = Tier<LOrOp,LogicalAnd>;// a || b
TernaryExpression : Box<Expression> = {
	<start:@L> <condition:LogicalOr> "?" <true_branch:TernaryExpression>  ":" <false_branch:TernaryExpression> <end:@R> => 
		Box::new(
			Expression::TernaryExpression{
				condition,
				true_branch,
				false_branch,
				location:SourceSpan::new_between(start,end),
			}
		),
	LogicalOr
}

pub Expr=TernaryExpression;
Tier<Op,NextTier>: Box<Expression> = {
    <start:@L> <lhs:Tier<Op,NextTier>> <code:Op> <rhs:NextTier> <end:@R> => 
	Box::new(
		Expression::BinaryExpression{
			lhs,
			rhs,
			code,
			location:SourceSpan::new_between(start,end),
		}
	),
    NextTier
};
ArgumentList=Comma<Expr>;
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T> => match v.len() { // (2)
        0 => v,
        _ => {
            v.push(e);
            v
        }
    }
};
RangeOp: RangeOpcode={
	":"  => RangeOpcode::Colon,
	"+:" => RangeOpcode::PlusColon,
}
ShiftOp: BinaryOpcode={
	">>" => BinaryOpcode::RShift,
	"<<" => BinaryOpcode::LShift,
}
BitwiseAndOp: BinaryOpcode={
	"&" => BinaryOpcode::BitwiseAnd
}
BitwiseXorOp: BinaryOpcode={
	"^" => BinaryOpcode::BitwiseXor
}
BitwiseOrOp:BinaryOpcode={
	"|" => BinaryOpcode::BitwiseOr
}
RelationalOp: BinaryOpcode={
	">" => BinaryOpcode::Less,
	"<" => BinaryOpcode::Greater,
	"<=" => BinaryOpcode::LessEqual,
	">=" => BinaryOpcode::GreaterEqual
}
EqualityOp: BinaryOpcode = {
	"==" => BinaryOpcode::Equal,
	"!=" => BinaryOpcode::NotEqual,
}
LAandOP: BinaryOpcode= {
	"&&" => BinaryOpcode::LogicalAnd
}
LOrOp: BinaryOpcode ={
	"||" => BinaryOpcode::LogicalOr
}
AddOp: BinaryOpcode = { // (3)
    "+" => BinaryOpcode::Addition,
    "-" => BinaryOpcode::Substraction,
};
FactorOp: BinaryOpcode = {
    "*" => BinaryOpcode::Multiplication,
	"%" => BinaryOpcode::Modulo,
    "/" => BinaryOpcode::Division,
};
UnaryExprOP :UnaryOpcode={
	"~" => UnaryOpcode::BitwiseNot,
	"!" => UnaryOpcode::LogicalNot,
	"+" => UnaryOpcode::Plus,
	"-" => UnaryOpcode::Minus,
}
TypeName: TypeSpecifier = {
	<start:@L> "auto" <end:@R> => TypeSpecifier::Auto{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "int" <end:@R> => TypeSpecifier::Int{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "wire" <end:@R> => TypeSpecifier::Wire{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "bool" <end:@R> => TypeSpecifier::Bool{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "bus" "<" <width:Expr> ">" <end:@R> => TypeSpecifier::Bus{
		width,
		location:SourceSpan::new_between(start,end),
	},
}
TypeQualifier: TypeQualifier = {

}
extern {
    type Location = usize;
    type Error = LexerError;
  
    enum TokenKind {
		"Number"          => TokenKind::Number(<u64>),
		"Id"              => TokenKind::Id(<IdTableKey>),
		"module"          => TokenKind::Keyword(KeywordKind::Module),
		"register"        => TokenKind::Keyword(KeywordKind::Register),
		"input"           => TokenKind::Keyword(KeywordKind::Input),
		"output"          => TokenKind::Keyword(KeywordKind::Output),
		"wire"            => TokenKind::Keyword(KeywordKind::Wire),
		"sync"            => TokenKind::Keyword(KeywordKind::Sync),
		"clock"           => TokenKind::Keyword(KeywordKind::Clock),
		"conditional"     => TokenKind::Keyword(KeywordKind::Conditional),
		"match"           => TokenKind::Keyword(KeywordKind::Match),
		"bus"             => TokenKind::Keyword(KeywordKind::Bus),
		"comb"            => TokenKind::Keyword(KeywordKind::Comb),
		"tristate"        => TokenKind::Keyword(KeywordKind::Tristate),
		"int"             => TokenKind::Keyword(KeywordKind::Int),
		"signed"          => TokenKind::Keyword(KeywordKind::Signed),
		"unsigned"        => TokenKind::Keyword(KeywordKind::Unsigned),
		"auto"            => TokenKind::Keyword(KeywordKind::Auto),
		"unused"          => TokenKind::Keyword(KeywordKind::Unused),
		"const"           => TokenKind::Keyword(KeywordKind::Const),
		"ff_sync"         => TokenKind::Keyword(KeywordKind::FfSync),
		"clock_gate"      => TokenKind::Keyword(KeywordKind::ClockGate),
		"tristate_buffer" => TokenKind::Keyword(KeywordKind::TristateBuffer),
		"enum"            => TokenKind::Keyword(KeywordKind::Enum),
		"if"              => TokenKind::Keyword(KeywordKind::If),
		"for"             => TokenKind::Keyword(KeywordKind::For),
		"bool"             => TokenKind::Keyword(KeywordKind::Bool),
		"("               => TokenKind::Punctuator(PunctuatorKind::LPar),
		")"               => TokenKind::Punctuator(PunctuatorKind::RPar),
		"{"               => TokenKind::Punctuator(PunctuatorKind::LBrace),
		"}"               => TokenKind::Punctuator(PunctuatorKind::RBrace),
		"["               => TokenKind::Punctuator(PunctuatorKind::LBracket),
		"]"               => TokenKind::Punctuator(PunctuatorKind::RBracket),
		";"               => TokenKind::Punctuator(PunctuatorKind::Semicolon),
		"+"               => TokenKind::Punctuator(PunctuatorKind::Plus),
		"-"               => TokenKind::Punctuator(PunctuatorKind::Minus),
		"!"               => TokenKind::Punctuator(PunctuatorKind::LogicalNot),
		"~"               => TokenKind::Punctuator(PunctuatorKind::BitwiseNot),
		"/"               => TokenKind::Punctuator(PunctuatorKind::Slash),
		"*"               => TokenKind::Punctuator(PunctuatorKind::Asterisk),
		"%"               => TokenKind::Punctuator(PunctuatorKind::Modulo),
		","				  => TokenKind::Punctuator(PunctuatorKind::Comma),
		"."				  => TokenKind::Punctuator(PunctuatorKind::Dot),
		"|"				  => TokenKind::Punctuator(PunctuatorKind::BitwiseOr),
		"^"				  => TokenKind::Punctuator(PunctuatorKind::BitwiseXor),
		"&"				  => TokenKind::Punctuator(PunctuatorKind::BitwiseAnd),
		">"				  => TokenKind::Punctuator(PunctuatorKind::Greater),
		"<"				  => TokenKind::Punctuator(PunctuatorKind::Less),
		"?"				  => TokenKind::Punctuator(PunctuatorKind::QuestionMark),
		":"				  => TokenKind::Punctuator(PunctuatorKind::Colon),
		">>"			  => TokenKind::Punctuator(PunctuatorKind::RShift),
		"<<"			  => TokenKind::Punctuator(PunctuatorKind::LShift),
		"<="			  => TokenKind::Punctuator(PunctuatorKind::LessEqual),
		">="			  => TokenKind::Punctuator(PunctuatorKind::GreaterEqual),
		"=="			  => TokenKind::Punctuator(PunctuatorKind::Equals),
		"!="			  => TokenKind::Punctuator(PunctuatorKind::NotEquals),
		"&&"			  => TokenKind::Punctuator(PunctuatorKind::LogicalAnd),
		"||"			  => TokenKind::Punctuator(PunctuatorKind::LogicalOr),
		"+:"			  => TokenKind::Punctuator(PunctuatorKind::PlusColon),




    }
  }