use crate::parser::ast::{ Expression, BinaryOpcode, RangeOpcode, UnaryOpcode,
	 TypeSpecifier, TypeQualifier, TypeDeclarator, TypeName, MatchExpressionStatement,
	 MatchExpressionAntecendent,TopDefinition,ModuleDeclarationStatement,VariableBlock,
	 VariableBlockStatement, VariableDeclaration, DirectDeclarator,ModuleImplementationStatement,
	 PortBindStatement,DirectInitializer,VariableDefinition,AssignmentOpcode,Root, RangeExpression, SourceLocation, ImportPath, Start, Modules};
use crate::lexer::*;
use crate::parser::*; 
use crate::SourceSpan;
grammar<'source>(ctx: & mut ParserContext<'source>, source: Option<&'source String>);
MetadataComments = NonEmptySpace<"MC">;
pub Izulu: Root={
	<start: @L> <definitions:NonEmptySpace<TopDef>> <end: @R> =>
		Root{
			definitions,
			location:SourceSpan::new_between(start,end),
		}
}
TopDef: TopDefinition={
	<start: @L> <mc:MetadataComments ?> "module" <id:"Id"> "{" <statements:Space<ModuleDeclStmt>> "}" <end: @R> =>
		{
			let metadata = match mc{
			Some(mc) => mc,
			None => vec![],
		};
		TopDefinition::ModuleDeclaration{
			metadata,
			id,
			statements,
			location:SourceSpan::new_between(start,end),
		}
	},
	<start: @L> <mc:MetadataComments ?> "impl" <id:"Id">  <statement:ModuleImplBlockStmt>  <end: @R> =>
	{
		let metadata = match mc{
		Some(mc) => mc,
		None => vec![],
	};	
	TopDefinition::ModuleImplementation{
			metadata,
			id,
			statement,
			location:SourceSpan::new_between(start,end),
		}},
	<start: @L> <mc:MetadataComments ?> "package" <path:ImportPath> ";"  <end: @R> =>
		{
			let metadata = match mc{
				Some(mc) => mc,
				None => vec![],
			};
			TopDefinition::PackageDeclaration{
				metadata,
				path,
				location:SourceSpan::new_between(start,end),
			}

		},
		<start: @L> <mc:MetadataComments ?> "use" <path:ImportPath> ";"  <end: @R> =>
		{
			let metadata = match mc{
				Some(mc) => mc,
				None => vec![],
			};
			TopDefinition::UseStatement{
				metadata,
				path,
				location:SourceSpan::new_between(start,end),
			}

		},
}
ImportPath: ImportPath={
	<start: @L> <quantity: ("super" "::")+> <path:DoubleColon<"Id">> <modules:Modules> <end: @R> =>{
		ImportPath{
			start:Start::Super{
				number: quantity.len()
			},
			path,
			modules,
			location:SourceSpan::new_between(start,end),
		}
	},
	<start: @L> "root" "::" <path:DoubleColon<"Id">> <modules:Modules> <end: @R> =>{
		ImportPath{
			start:Start::Root,
			path,
			modules,
			location:SourceSpan::new_between(start,end),
		}
	},
	<start: @L> <path:DoubleColon<"Id">> <modules:Modules> <end: @R> =>{
		ImportPath{
			start:Start::Local,
			path,
			modules,
			location:SourceSpan::new_between(start,end),
		}
	},
}
Modules :Modules = {
	<id:"Id"> => Modules::Specific{modules: vec![id]},
	"{" <modules:NonEmptyOptComma<"Id">> "}" => Modules::Specific{modules},
	"*" => Modules::All,
}
ModuleImplStmt: Box<ModuleImplementationStatement> = {
	<start: @L>  <block:VarBlock> <end: @R> =>
		Box::new(
			ModuleImplementationStatement::VariableBlock{
		   		block,
		   		location:SourceSpan::new_between(start,end),
	    	}
		),
	<start: @L>  <definition:VarDef> Semicolon <end: @R> =>
	    Box::new(
		    ModuleImplementationStatement::VariableDefinitionStatement{
				definition,
				location:SourceSpan::new_between(start,end),
	    	}
		),
	<start: @L>  <lhs:Expr> <assignment_opcode:AssignmentOP> <rhs:ExprWithTuple> Semicolon <end: @R> =>
		Box::new(
			ModuleImplementationStatement::AssignmentStatement{
				lhs,
				assignment_opcode,
				rhs,
				location:SourceSpan::new_between(start,end),
	    	}
	  	),
	
	<start: @L> "for" LPar <id:"Id"> In <range:RangeExpr> ")" <statement:ModuleImplBlockStmt> <end: @R> =>
		Box::new(
			ModuleImplementationStatement::IterationStatement{
				id,
				range,
				statement,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start: @L> <mc :MetadataComments?> <module_name:"Id"> <instance_name:"Id"> "{" <port_bind:NonEmptyOptComma<PortBindStmt>> "}" <a:";"?> <end: @R> =>
		{
			let metadata = match mc{
			Some(mc) => mc,
			None => vec![],
		};		
			Box::new(
				ModuleImplementationStatement::InstantiationStatement{
					metadata,
					module_name,
					instance_name,
					port_bind,
					location:SourceSpan::new_between(start,end),
			}
		)
		},
		ModuleImplBlockStmt,	
		IfStmt,			
}
ModuleImplBlockStmt: Box<ModuleImplementationStatement> ={
	<start: @L>  "{" <statements:NonEmptySpace<ModuleImplStmt>> "}" <end: @R> =>
		Box::new(
			ModuleImplementationStatement::ModuleImplementationBlockStatement{
				statements,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start: @L>  "{"  "}" <end: @R> =>
		Box::new(
			ModuleImplementationStatement::ModuleImplementationBlockStatement{
				statements:vec![],
				location:SourceSpan::new_between(start,end),
			}
		),
}
IfStmt: Box<ModuleImplementationStatement> ={
	
	<start: @L> "if"  LPar <condition:Expr> ")" <if_statement:ModuleImplBlockStmt> "else" <else_statement:ModuleImplBlockStmt> <end: @R> =>
		Box::new(
			ModuleImplementationStatement::IfElseStatement{
				condition,
				if_statement,
				else_statement,
				location:SourceSpan::new_between(start,end),
	    	}
		),
	<start: @L> "if"  LPar <condition:Expr> ")" <if_statement:ModuleImplBlockStmt> "else" <else_statement:IfStmt> <end: @R> =>
		Box::new(
			ModuleImplementationStatement::IfElseStatement{
				condition,
				if_statement,
				else_statement,
				location:SourceSpan::new_between(start,end),
	    	}
		),
	<start: @L> "if" LPar <condition:Expr> ")"  <if_statement:ModuleImplBlockStmt> <end: @R> =>
		Box::new(
			ModuleImplementationStatement::IfStatement{
				condition,
				if_statement,
				location:SourceSpan::new_between(start,end),
	    	}
		),
}
pub PortBindStmt: PortBindStatement={
	<start:@L> <id:"Id"> <end:@R> =>
		PortBindStatement::OnlyId{
			id,
			location:SourceSpan::new_between(start,end),
		},
	<start:@L> <id:"Id"> ":" <expression:ExprWithTuple> <end:@R> =>
		PortBindStatement::IdWithExpression{
			id,
			expression,
			location:SourceSpan::new_between(start,end),
		},
	<start:@L> <id:"Id"> ":" <declaration:SingleVarDecl> <end:@R> =>
		PortBindStatement::IdWithDeclaration{
			id,
			declaration,
			location:SourceSpan::new_between(start,end),
		},
}
VarDef: VariableDefinition={
	<start: @L> <mc: MetadataComments ?> <type_declarator:TypeDeclarator> <initializer_list:NonEmptyComma<DirectInitializer>> <end: @R> =>
	{
		let metadata = match mc{
		Some(mc) => mc,
		None => vec![],
	};	
	VariableDefinition{
		metadata,
		type_declarator,
		initializer_list,
		location:SourceSpan::new_between(start,end),
	}
}
}
DirectInitializer: DirectInitializer = {
	<start: @L>  <declarator:DirectDecl> <end: @R> =>{
		let expression = None;
		DirectInitializer{
			declarator,
			expression,
			location:SourceSpan::new_between(start,end),
		}},
	<start: @L>  <declarator:DirectDecl> "=" <expr:ExprWithTuple> <end: @R> =>
	{
	let expression = Some(expr);
	DirectInitializer{
		declarator,
		expression,
		location:SourceSpan::new_between(start,end),
	}
},
}
ModuleDeclStmt: ModuleDeclarationStatement={
	<start: @L>  <declaration:VarDecl> Semicolon <end: @R> =>
 		ModuleDeclarationStatement::VariableDeclarationStatement{
			declaration,
			location:SourceSpan::new_between(start,end),
		},
	<start: @L>  <block:VarBlock> <end: @R> =>
 		ModuleDeclarationStatement::VariableBlock{
			block,
			location:SourceSpan::new_between(start,end),
		},
	
}
VarBlock: Box<VariableBlock>={
	<start: @L> <mc: MetadataComments ?> <dir:Direction?> <mut types:NonEmptySpace<Qualifier>> "{" <statements:Space<VarBlockStmt>> RBrace Semicolon <end: @R> =>
		{
			let metadata = match mc{
			Some(mc) => mc,
			None => vec![],
		};	
		if let Some(d)=dir{
			types.splice(0..0, [d]);
		};
		Box::new(VariableBlock{
			metadata,
			types,
			statements,
			location:SourceSpan::new_between(start,end),
		})
	},
}
VarBlockStmt: VariableBlockStatement={
	<start: @L>  <block:VarBlock> <end: @R> =>
		VariableBlockStatement::VariableBlock{
	   		block,
	   		location:SourceSpan::new_between(start,end),
		},
	<start: @L>  <declaration:VarDecl> Semicolon <end: @R> =>
		VariableBlockStatement::VariableDeclarationStatement{
			declaration,
	   		location:SourceSpan::new_between(start,end),
		},
}

VarDecl: VariableDeclaration = {
	<start: @L> <mc: MetadataComments?> <type_declarator:TypeDeclarator> <direct_declarators:NonEmptyComma<DirectDecl>> <end: @R>=>
	{
		let metadata = match mc{
		Some(mc) => mc,
		None => vec![],
		};		
		VariableDeclaration{
			metadata,
			type_declarator,
			direct_declarators,
			location:SourceSpan::new_between(start,end),
		}
	},
}
SingleVarDecl: VariableDeclaration = {
	<start: @L>  <type_declarator:TypeDeclarator> <direct_declarator:DirectDecl> <end: @R>=>
		VariableDeclaration{
			metadata:vec![],
			type_declarator,
			direct_declarators: vec![direct_declarator],
			location:SourceSpan::new_between(start,end),
		},
}
DirectDecl: Box<DirectDeclarator> = {
	<start: @L>  <name:"Id"> <array_declarators:Space<IndexExpr>> <end: @R>=>
		Box::new(
			DirectDeclarator{
				name,
				array_declarators,
				location:SourceSpan::new_between(start,end),
		})
}

MatchExpressionStatement: MatchExpressionStatement = {
	<start: @L> <antecedent:MatchExpressionAntecendent> "=>" <expression:Expr> <end: @R> =>
		MatchExpressionStatement{
			antecedent,
			expression,
			location:SourceSpan::new_between(start,end),
		}
}
MatchExpressionAntecendent: MatchExpressionAntecendent = {
	<start: @L> <expressions:NonEmptyComma<Expr>> <end: @R> => MatchExpressionAntecendent::Expression{
		expressions,
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "default" <end:@R> =>MatchExpressionAntecendent::Default{
		location:SourceSpan::new_between(start,end),
	},
}
PrimaryExpression: Box<Expression> = {
	<start:@L> <key:"NumericConstant"> <end:@R> => 
		Box::new(
			Expression::Number{
				key,
				location:SourceSpan::new_between(start,end)
			}
		),
	<start:@L> <id:"Id"> <end:@R> => 
		Box::new(
			Expression::Identifier{
				id,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L> "(" <expression:Expr> ")" <end:@R> => 
		Box::new(
			Expression::ParenthesizedExpression{
				expression,
				location:SourceSpan::new_between(start,end)
			}
		),
	
	<start:@L> "match" "(" <value:Expr> ")" "{" <statements:NonEmptyOptComma<MatchExpressionStatement>> "}" <end:@R> =>
		Box::new(
			Expression::MatchExpression{
				value,
				statements,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L> "conditional" "{" <statements:NonEmptyOptComma<MatchExpressionStatement>> RBrace <end:@R> =>
		Box::new(
			Expression::ConditionalExpression{
				statements,
				location:SourceSpan::new_between(start,end),
			}
		),
}
ExprWithTuple:Box<Expression>={
	TupleExpr,
	Expr,
}
TupleExpr: Box<Expression> ={
	<start:@L> "{" <expressions:OptComma<Expr>> RBrace <end:@R> =>
		Box::new(
			Expression::Tuple{
				expressions,
				location:SourceSpan::new_between(start,end)
			}
		),
}
pub RangeExpr :  RangeExpression = {
	<start:@L> "[" <lhs:Expr> <code:RangeOp> <rhs:Expr> "]" <end:@R> =>
		RangeExpression{
			lhs,
			rhs,
			code,
			location:SourceSpan::new_between(start,end)
		}
}
IndexExpr : Box<Expression> ={
	"[" <Expr> "]"
}
PostfixExpr: Box<Expression>={
	<start:@L> <expression:PostfixExpr> "." <id:"Id"> <end:@R> =>
		Box::new(
			Expression::PostfixWithId{
				expression,
				id,
				location:SourceSpan::new_between(start,end),
		}
	),
	<start:@L> <expression:PostfixExpr> <index:IndexExpr> <end:@R> =>
		Box::new(
			Expression::PostfixWithIndex{
				expression,
				index,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L> <expression:PostfixExpr> <range:RangeExpr> <end:@R> =>
		Box::new(
			Expression::PostfixWithRange{
				expression,
				range,
				location:SourceSpan::new_between(start,end),
			}
		),
	<start:@L> <expression:PostfixExpr> "(" <args:ArgumentList ?> ")" <end:@R> =>
		match args{
			None => {
				let argument_list= vec![];
				Box::new(
					Expression::PostfixWithArgs{
					expression,
					argument_list,
					location:SourceSpan::new_between(start,end),
				}
				)
			},
			Some(argument_list) =>Box::new(
				Expression::PostfixWithArgs{
					expression,
					argument_list,
					location:SourceSpan::new_between(start,end),
				}
			),
		},		
	PrimaryExpression,
}
UnaryExpr: Box<Expression> ={
	<start:@L> <code:UnaryExprOP> <expression:PostfixExpr>  <end:@R> => 
	Box::new(
		Expression::UnaryOperatorExpression{
			expression,
			code,
			location:SourceSpan::new_between(start,end),
		}
	),
	<start:@L> "(" <type_name:TypeName> ")" <expression:PostfixExpr>  <end:@R> => 
	Box::new(
		Expression::UnaryCastExpression{
			type_name,
			expression,
			location:SourceSpan::new_between(start,end),
		}
	),
	PostfixExpr,
}
Factor = Tier<FactorOp, UnaryExpr>;
Sum = Tier<AddOp, Factor>;
Shift = Tier<ShiftOp,Sum>;
BitwiseAnd = Tier<BitwiseAndOp,Shift>;
BitwiseXor = Tier<BitwiseXorOp,BitwiseAnd>;
BitwiseOr= Tier<BitwiseOrOp,BitwiseXor>;
Comparison = Tier<RelationalOp,BitwiseOr>;
Equality = Tier<EqualityOp,Comparison>;
LogicalAnd = Tier<LAandOP,Equality>;
LogicalOr = Tier<LOrOp,LogicalAnd>;// a || b
TernaryExpression : Box<Expression> = {
	<start:@L> <condition:LogicalOr> "?" <true_branch:TernaryExpression>  ":" <false_branch:TernaryExpression> <end:@R> => 
		Box::new(
			Expression::TernaryExpression{
				condition,
				true_branch,
				false_branch,
				location:SourceSpan::new_between(start,end),
			}
		),
	LogicalOr
}

pub Expr=TernaryExpression;
Tier<Op,NextTier>: Box<Expression> = {
    <start:@L> <lhs:Tier<Op,NextTier>> <code:Op> <rhs:NextTier> <end:@R> => 
	Box::new(
		Expression::BinaryExpression{
			lhs,
			rhs,
			code,
			location:SourceSpan::new_between(start,end),
		}
	),
    NextTier
};
ArgumentList=NonEmptyCommaErr<Expr>;
NonEmptyCommaErr<T>: Vec<T> = { // (1)
    <mut v:(<T> Comma)*> <e:T> => match v.len() { // (2)
        0 => vec![e],
        _ => {
            v.push(e);
            v
        }
    }
};
NonEmptyComma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T> => match v.len() { // (2)
        0 => vec![e],
        _ => {
            v.push(e);
            v
        }
    }
};
OptComma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
#[inline]
DoubleColon<T>: Vec<T> = { // (1)
    <v:(<T> "::")+> => v
};
NonEmptyOptComma<T>: Vec<T> = { // (1)
    <b:T> <mut v:("," <T>)*> ","? => match v.len() { // (2)
        0 => {
			v.push(b);
			v
		}
        _  => {
            v.splice(0..0, [b]);
            v
        }
    }
};
Space<T>: Vec<T> = { // (1)
    <v:(<T>)*> => v
};
NonEmptySpace<T>: Vec<T> = { // (1)
    <v:(<T>)+> => v
};
RangeOp: RangeOpcode={
	":"  => RangeOpcode::Colon,
	"+:" => RangeOpcode::PlusColon,
}
ShiftOp: BinaryOpcode={
	">>" => BinaryOpcode::RShift,
	"<<" => BinaryOpcode::LShift,
}
BitwiseAndOp: BinaryOpcode={
	"&" => BinaryOpcode::BitwiseAnd
}
BitwiseXorOp: BinaryOpcode={
	"^" => BinaryOpcode::BitwiseXor
}
BitwiseOrOp:BinaryOpcode={
	"|" => BinaryOpcode::BitwiseOr
}
RelationalOp: BinaryOpcode={
	">" => BinaryOpcode::Greater,
	"<" => BinaryOpcode::Less,
	"<=" => BinaryOpcode::LessEqual,
	">=" => BinaryOpcode::GreaterEqual
}
EqualityOp: BinaryOpcode = {
	"==" => BinaryOpcode::Equal,
	"!=" => BinaryOpcode::NotEqual,
}
LAandOP: BinaryOpcode= {
	"&&" => BinaryOpcode::LogicalAnd
}
LOrOp: BinaryOpcode ={
	"||" => BinaryOpcode::LogicalOr
}
AddOp: BinaryOpcode = { // (3)
    "+" => BinaryOpcode::Addition,
    "-" => BinaryOpcode::Substraction,
};
FactorOp: BinaryOpcode = {
    "*" => BinaryOpcode::Multiplication,
	"%" => BinaryOpcode::Modulo,
    "/" => BinaryOpcode::Division,
};
UnaryExprOP :UnaryOpcode={
	"~" => UnaryOpcode::BitwiseNot,
	"!" => UnaryOpcode::LogicalNot,
	"+" => UnaryOpcode::Plus,
	"-" => UnaryOpcode::Minus,
}
AssignmentOP: AssignmentOpcode={
	"="  => AssignmentOpcode::Equal,
	"+=" => AssignmentOpcode::PlusEqual,
	"&=" => AssignmentOpcode::AndEqual,
	"^=" => AssignmentOpcode::XorEqual,
	"|=" => AssignmentOpcode::OrEqual,
}
SynType: TypeSpecifier ={
	<start:@L> "auto" <end:@R> => TypeSpecifier::Auto{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "wire" <end:@R> => TypeSpecifier::Wire{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "bus" <width:VecDecl> <end:@R> => TypeSpecifier::Bus{
		width,
		location:SourceSpan::new_between(start,end),
	},
}
CompType: TypeSpecifier = {
	<start:@L> "int" <end:@R> => TypeSpecifier::Int{
		location:SourceSpan::new_between(start,end),
	},	
	<start:@L> "bool" <end:@R> => TypeSpecifier::Bool{
		location:SourceSpan::new_between(start,end),
	},	
}
VecDecl: Box<Expression>={
	"<" <PrimaryExpression> ">",
}
QualifierWithDirection={
	Direction,
	Qualifier,
}
Direction: TypeQualifier={
	<start:@L> "input" <end:@R> => TypeQualifier::Input{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "output" <end:@R> => TypeQualifier::Output{
		location:SourceSpan::new_between(start,end),
	},
}
Qualifier: TypeQualifier = {
	<start:@L> "signed" <end:@R> => TypeQualifier::Signed{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "unsigned" <end:@R> => TypeQualifier::Unsigned{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "tristate" <end:@R> => TypeQualifier::Tristate{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "const" <end:@R> => TypeQualifier::Const{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "async" <end:@R> => TypeQualifier::Async{
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "comb" LPar <expression:Expr> ")" <end:@R> => TypeQualifier::Comb{
		expression,
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "sync" LPar <expressions:NonEmptyComma<Expr>> ")" <end:@R> => TypeQualifier::Sync{
		expressions,
		location:SourceSpan::new_between(start,end),
	},
	<start:@L> "clock" <end:@R> => TypeQualifier::Clock{
		location:SourceSpan::new_between(start,end),
	},
	
}
TypeDeclarator: TypeDeclarator ={
	<start:@L> <dir:Direction?> <mut qualifiers:Space<Qualifier>> <specifier:SynType> <end:@R> =>{
		if let Some(d)=dir{
			qualifiers.splice(0..0, [d]);
		};
		TypeDeclarator{
		specifier,
		qualifiers,
		location:SourceSpan::new_between(start,end),
		}
	},
	<start:@L> <dir:Direction?> <specifier:CompType> <end:@R> =>{
		let qualifiers = match dir{
			Some(dir) => vec![dir],
			None => vec![],
		};
		TypeDeclarator{
		specifier,
		qualifiers,
		location:SourceSpan::new_between(start,end),
		}
	},
	<start:@L> <dir:Direction?> <mut qualifiers:NonEmptySpace<Qualifier>> <bus_expr:VecDecl?> <end:@R> =>{
		if let Some(d)=dir{
			qualifiers.splice(0..0, [d]);
		};
		let specifier = match bus_expr{
			Some(expr) => TypeSpecifier::Bus{
				location: expr.get_location(),
				width: expr,
			},
			None => TypeSpecifier::Wire{
				location:SourceSpan::new_between(start,end),
			},
		};
		TypeDeclarator{
		specifier,
		qualifiers,
		location:SourceSpan::new_between(start,end),
		}
	},
	<start:@L> <dir:Direction> <bus_expr:VecDecl?> <end:@R> =>{
		let qualifiers = vec![dir];
		let specifier = match bus_expr{
			Some(expr) => TypeSpecifier::Bus{
				location: expr.get_location(),
				width: expr,
			},
			None => TypeSpecifier::Wire{
				location:SourceSpan::new_between(start,end),
			},
		};
		TypeDeclarator{
		specifier,
		qualifiers,
		location:SourceSpan::new_between(start,end),
		}
	},
}
TypeName: TypeName ={
	<start:@L> <declarator:TypeDeclarator> <array_declarators:Space<IndexExpr>> <end:@R> => TypeName{
		declarator,
		array_declarators,
		location:SourceSpan::new_between(start,end),
	}
}
Comma = {
	",",
	<start:@L> !  =>{
		ctx.diagnostic_buffer.push_diagnostic(ParserError{
			kind: ParserErrorKind::MissingToken(TokenKind::Punctuator(PunctuatorKind::Comma)),
			range: SourceSpan::new_between(start,start),
		}.to_diagnostic(),source);
		//println!("Missing Semicolon"); // for debugging
		TokenKind::Punctuator(PunctuatorKind::Comma)
	}
}
RBrace = {
	"}",
	<start:@L> !  =>{
		ctx.diagnostic_buffer.push_diagnostic(ParserError{
			kind: ParserErrorKind::MissingToken(TokenKind::Punctuator(PunctuatorKind::RBrace)),
			range: SourceSpan::new_between(start,start),
		}.to_diagnostic(),source);
		//println!("Missing Semicolon"); // for debugging
		TokenKind::Punctuator(PunctuatorKind::RBrace)
	}
}
LBrace = {
	"{",
	<start:@L> !  =>{
		ctx.diagnostic_buffer.push_diagnostic(ParserError{
			kind: ParserErrorKind::MissingToken(TokenKind::Punctuator(PunctuatorKind::LBrace)),
			range: SourceSpan::new_between(start,start),
		}.to_diagnostic(),source);
		//println!("Missing Semicolon"); // for debugging
		TokenKind::Punctuator(PunctuatorKind::LBrace)
	}
 }
Semicolon = {
	 ";" ,
	 <start:@L> !  =>{
		ctx.diagnostic_buffer.push_diagnostic(ParserError{
			kind: ParserErrorKind::MissingToken(TokenKind::Punctuator(PunctuatorKind::Semicolon)),
			range: SourceSpan::new_between(start,start),
		}.to_diagnostic(),source);
		//println!("Missing Semicolon"); // for debugging
		TokenKind::Punctuator(PunctuatorKind::Semicolon)
	}
}
LPar = {
	"(" ,
	<start:@L> !  =>{
	   ctx.diagnostic_buffer.push_diagnostic(ParserError{
		   kind: ParserErrorKind::MissingToken(TokenKind::Punctuator(PunctuatorKind::LPar)),
		   range: SourceSpan::new_between(start,start),
	   }.to_diagnostic(),source);
	   //println!("Missing Semicolon"); // for debugging
	   TokenKind::Punctuator(PunctuatorKind::LPar)
   }
}
In = {
	"in" ,
	<start:@L> !  =>{
	   ctx.diagnostic_buffer.push_diagnostic(ParserError{
		   kind: ParserErrorKind::MissingToken(TokenKind::Keyword(KeywordKind::In)),
		   range: SourceSpan::new_between(start,start),
	   }.to_diagnostic(),source);
	   //println!("Missing Semicolon"); // for debugging
	   TokenKind::Keyword(KeywordKind::In)
   }
}
extern {
    type Location = usize;
    type Error = LexerError;
  
    enum TokenKind {
		"NumericConstant" => TokenKind::NumericConstant(<NumericConstantTableKey>),
		"Id"              => TokenKind::Id(<IdTableKey>),
		"module"          => TokenKind::Keyword(KeywordKind::Module),
		"input"           => TokenKind::Keyword(KeywordKind::Input),
		"output"          => TokenKind::Keyword(KeywordKind::Output),
		"wire"            => TokenKind::Keyword(KeywordKind::Wire),
		"sync"            => TokenKind::Keyword(KeywordKind::Sync),
		"async"           => TokenKind::Keyword(KeywordKind::Async),
		"clock"           => TokenKind::Keyword(KeywordKind::Clock),
		"impl"            => TokenKind::Keyword(KeywordKind::Impl),
		"conditional"     => TokenKind::Keyword(KeywordKind::Conditional),
		"match"           => TokenKind::Keyword(KeywordKind::Match),
		"bus"             => TokenKind::Keyword(KeywordKind::Bus),
		"comb"            => TokenKind::Keyword(KeywordKind::Comb),
		"tristate"        => TokenKind::Keyword(KeywordKind::Tristate),
		"int"             => TokenKind::Keyword(KeywordKind::Int),
		"signed"          => TokenKind::Keyword(KeywordKind::Signed),
		"unsigned"        => TokenKind::Keyword(KeywordKind::Unsigned),
		"default"         => TokenKind::Keyword(KeywordKind::Default),
		"auto"            => TokenKind::Keyword(KeywordKind::Auto),
		"unused"          => TokenKind::Keyword(KeywordKind::Unused),
		"const"           => TokenKind::Keyword(KeywordKind::Const),
		"enum"            => TokenKind::Keyword(KeywordKind::Enum),
		"if"              => TokenKind::Keyword(KeywordKind::If),
		"else"            => TokenKind::Keyword(KeywordKind::Else),
		"in"              => TokenKind::Keyword(KeywordKind::In),
		"for"             => TokenKind::Keyword(KeywordKind::For),
		"bool"            => TokenKind::Keyword(KeywordKind::Bool),
		"super"           => TokenKind::Keyword(KeywordKind::Super),
		"package"         => TokenKind::Keyword(KeywordKind::Package),
		"use"             => TokenKind::Keyword(KeywordKind::Use),
		"root"            => TokenKind::Keyword(KeywordKind::Root),
		"("               => TokenKind::Punctuator(PunctuatorKind::LPar),
		")"               => TokenKind::Punctuator(PunctuatorKind::RPar),
		"{"               => TokenKind::Punctuator(PunctuatorKind::LBrace),
		"}"               => TokenKind::Punctuator(PunctuatorKind::RBrace),
		"["               => TokenKind::Punctuator(PunctuatorKind::LBracket),
		"]"               => TokenKind::Punctuator(PunctuatorKind::RBracket),
		";"               => TokenKind::Punctuator(PunctuatorKind::Semicolon),
		"+"               => TokenKind::Punctuator(PunctuatorKind::Plus),
		"-"               => TokenKind::Punctuator(PunctuatorKind::Minus),
		"!"               => TokenKind::Punctuator(PunctuatorKind::LogicalNot),
		"~"               => TokenKind::Punctuator(PunctuatorKind::BitwiseNot),
		"/"               => TokenKind::Punctuator(PunctuatorKind::Slash),
		"*"               => TokenKind::Punctuator(PunctuatorKind::Asterisk),
		"="               => TokenKind::Punctuator(PunctuatorKind::Assignment),
		"+="              => TokenKind::Punctuator(PunctuatorKind::AssignmentPlus),
		"&="              => TokenKind::Punctuator(PunctuatorKind::AssignmentAnd),
		"^="              => TokenKind::Punctuator(PunctuatorKind::AssignmentXor),
		"|="              => TokenKind::Punctuator(PunctuatorKind::AssignmentOr),
		"%"               => TokenKind::Punctuator(PunctuatorKind::Modulo),
		","				  => TokenKind::Punctuator(PunctuatorKind::Comma),
		"."				  => TokenKind::Punctuator(PunctuatorKind::Dot),
		"|"				  => TokenKind::Punctuator(PunctuatorKind::BitwiseOr),
		"^"				  => TokenKind::Punctuator(PunctuatorKind::BitwiseXor),
		"&"				  => TokenKind::Punctuator(PunctuatorKind::BitwiseAnd),
		">"				  => TokenKind::Punctuator(PunctuatorKind::Greater),
		"<"				  => TokenKind::Punctuator(PunctuatorKind::Less),
		"?"				  => TokenKind::Punctuator(PunctuatorKind::QuestionMark),
		":"				  => TokenKind::Punctuator(PunctuatorKind::Colon),
		"::"              => TokenKind::Punctuator(PunctuatorKind::DoubleColon),
		">>"			  => TokenKind::Punctuator(PunctuatorKind::RShift),
		"<<"			  => TokenKind::Punctuator(PunctuatorKind::LShift),
		"<="			  => TokenKind::Punctuator(PunctuatorKind::LessEqual),
		">="			  => TokenKind::Punctuator(PunctuatorKind::GreaterEqual),
		"=="			  => TokenKind::Punctuator(PunctuatorKind::Equals),
		"!="			  => TokenKind::Punctuator(PunctuatorKind::NotEquals),
		"&&"			  => TokenKind::Punctuator(PunctuatorKind::LogicalAnd),
		"||"			  => TokenKind::Punctuator(PunctuatorKind::LogicalOr),
		"+:"			  => TokenKind::Punctuator(PunctuatorKind::PlusColon),
		"=>"			  => TokenKind::Punctuator(PunctuatorKind::Implies),
		"MC"              => TokenKind::MetadataComment(<CommentTableKey>),


    }
  }