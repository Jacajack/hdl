module simple_adder {
	input bus<8> a;
	input bus<8> b;
	output bus<9> c;
}

impl simple_adder {
	c = a + b;
}

module generic_sync_adder {
	int IN_WIDTH;
	int OUT_WIDTH;
	input {
		clock clk;
		wire nreset;
		bus<IN_WIDTH> a;
		bus<IN_WIDTH> b;
	};
	output bus<OUT_WIDTH> c;
}

impl generic_sync_adder {
	register r{
		clk: auto,
		nreset: auto,
		next: (a + b)[0 :+ OUT_WIDTH],
		q,
	};
	c = q;
}

module vector_reducer {
	int N;
	int BITS;
	comb input bus<BITS> m[N]; // should warn about non-register input
	comb output bus<BITS + N> q; // should warn about non-register output
}

impl vector_reducer {
	node<N*BITS> s = 1; // TODO ones
	for (i = [0 : N-1]) {
		s += m[i];
	}
}


module state_machine {
	input clock clk;
	input nreset;
	input bus<2> d;
	output sync(clk) bus<2> dout;
}

impl state_machine {
	enum bus<2> st {
		IDLE,
		INIT,
		WORK,
		ABORT,
	};

	register s{
		clk: auto,
		nreset: auto,
		q: dout,
		next: fsm(s.q) {
			state st::IDLE {
				q == 1_u2 => st::INIT
			}

			state st::INIT {
				q == 0_u2 => st::WORK
			}

			state st::WORK {
				q == 1_u2 => st::INIT,
				default => st::ABORT,
			}

			state st::ABORT {
				default => st::IDLE
			}
		}
	};
}


module pipelined_is_prime {
	input clock clk;
	input nreset;

	input in_valid;
	output in_ready;
	input bus<4> number;

	input out_ready;
	output sync(clk) {
		wire is_prime;
		wire out_valid;
	};
};

impl pipelined_is_prime {
	in_ready = out_ready; // comb passthrough - should warn

	register out_valid_r {
		clk, // must be a clock signal
		nreset,
		en: true,
		data: out_valid,
		next: in_valid,
	};

	register is_prime_r {
		clk,    // auto connected
		nreset, // auto connected
		en: out_ready,
		data: is_prime, // type deduced from input, connects to 'output sync(clk)'
		next: match(number) {
			2_u4, 3_u4, 5_u4, 7_u4, 11_u4, 13_u4 => true, // or 1u1
			default => false,
		},
	};
}

module pipelined_is_prime(
	input wire clk,
	input wire nreset,

	input wire in_valid,
	output wire in_ready,
	input wire[3:0] number,

	input wire out_ready,
	output wire is_prime,
	output wire out_valid
);

assign in_ready = out_ready;

reg out_valid_r;
wire out_valid_nxt_c = in_valid;
wire out_valid_en_c = '1;

always @(posedge clk or nreset)
	if (!nreset)
		out_valid_r <= '0;
	else if (out_valid_en_c)
		out_valid_r <= out_valid_nxt_c;

reg is_prime_r;
wire is_prime_en_c = out_ready;
wire is_prime_nxt_c =
	(number == 4'd2)  ? '1 :
	(number == 4'd3)  ? '1 : 
	(number == 4'd5)  ? '1 : 
	(number == 4'd7)  ? '1 : 
	(number == 4'd11) ? '1 : 
	(number == 4'd13) ? '1 : '0;

always @(posedge clk or nreset)
	if (!nreset)
		is_prime_r <= '0;
	else if (is_prime_en_c)
		is_prime_r <= is_prime_nxt_c;

endmodule